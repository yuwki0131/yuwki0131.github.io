<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='https://yuwki0131.github.io/' rel='self' type='application/rss+xml'/>
<title>
何で走っているのだろう
</title>
<link>
https://yuwki0131.github.io/
</link>
<description>
This blog is a cartesian closed category
</description>
<lastBuildDate>
Sat, 26 Aug 2017 13:28:44 +0900
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
https://yuwki0131.github.io/posts-output/2017-08-26-make-a-lisp-minimum/
</guid>
<link>
https://yuwki0131.github.io/posts-output/2017-08-26-make-a-lisp-minimum/
</link>
<title>
最低限のLispを作るためのマイルストーン
</title>
<description>
&lt;p&gt;最低限のLispを作るためのメモです。&lt;/p&gt;&lt;h1 id=&quot;言語のアウトラインをパクる(r7rs)&quot;&gt;言語のアウトラインをパクる(R7RS)&lt;/h1&gt;&lt;p&gt;言語のアウトライン(特にSyntax)は一度見ておいた方がいい。 最低限のLispという点でCommon LispよりはScheme寄りになると思う。 独自のLispを作るのでR7RSの実装からは外れていくだろうが、実際の仕様書がどのように書かれているのかは一応参考にはなる。&lt;/p&gt;&lt;h1 id=&quot;lexer/parserを書く&quot;&gt;lexer/parserを書く&lt;/h1&gt;&lt;p&gt;最近はparser comibnatorがあるし、Lispは括弧で囲まれたリストとシンボルだけという基本的なシンタックスなので、 lexerとparserはまとめて実装できるはず。最初は代数的データ型やcase class(または普通のクラス?)も最低限の記法で間に合うかと。 動的型付け言語なら、もっとシンプルに普通にリストと(シンボルを表す)文字列というデータ型でいけてしまうかも。 後で、必要に応じて拡張していけばいい。&lt;/p&gt;&lt;h1 id=&quot;eval関数と環境を実装&amp;#95;(とりあえず、(+&amp;#95;1&amp;#95;2)が評価出来る所まで実装)&quot;&gt;eval関数と環境を実装 (とりあえず、(+ 1 2)が評価出来る所まで実装)&lt;/h1&gt;&lt;p&gt;eval関数を実装して、Lispの最も初歩的な文法である&lt;code&gt;&amp;#40;+ 1 2&amp;#41;&lt;/code&gt;が実行可能な所まで持っていく。 ちなみにLispでは、&lt;code&gt;+&lt;/code&gt;は演算子ではなく、関数。 ここまで行くと、モチベーションが格段に上がるので、&lt;code&gt;&amp;#40;+ 1 2&amp;#41;&lt;/code&gt;で結果が返ってくるような形まで作っておきたい。&lt;/p&gt;&lt;p&gt;必要になってくるのは、&lt;code&gt;&amp;#40;+ 1 2&amp;#41;&lt;/code&gt;を評価するための関数(evalと呼ばれるやつ)と、環境(変数名と値のペアのリスト)、 プリミティブ関数&lt;code&gt;+&lt;/code&gt;、number型(int型?)の実装。また、この時の&lt;code&gt;&amp;#40;+ 1 2&amp;#41;&lt;/code&gt;は、ネストさせて&lt;code&gt;&amp;#40;+ 1 &amp;#40;+ 2 3&amp;#41;&amp;#41;&lt;/code&gt;と書いても動くように しておくことが求められる。eval関数は再帰的に実装すること。 環境に関しては、環境から値を検索し取り出すための関数も必要となる。&lt;/p&gt;&lt;h1 id=&quot;プリミティブ(定数と関数)を実装&quot;&gt;プリミティブ(定数と関数)を実装&lt;/h1&gt;&lt;p&gt;&lt;code&gt;&amp;#40;+ 1 2&amp;#41;&lt;/code&gt;を評価できるeval関数が実装できたら、後はそれを引き伸ばしていくだけ。&lt;/p&gt;&lt;p&gt;booleanとnumberを操作する一連の関数を実装する。 booleanとnumberで計算が出来るレベルとなると、電卓っぽくなる。&lt;/p&gt;&lt;h1 id=&quot;ifを実装&quot;&gt;ifを実装&lt;/h1&gt;&lt;p&gt;最初の制御構文的な機能、&lt;code&gt;if&lt;/code&gt;を実装する。が、これは実際すごく簡単。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;if condition then-clause else-close&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;に対して、&lt;code&gt;condition&lt;/code&gt;を評価して、その結果のtrue/falseに合わせて、 &lt;code&gt;then-clause&lt;/code&gt;もしくは&lt;code&gt;else-clause&lt;/code&gt;のどちらかを評価し、その結果を返すだけ。&lt;/p&gt;&lt;h1 id=&quot;変数を実装(letを実装)&quot;&gt;変数を実装(letを実装)&lt;/h1&gt;&lt;p&gt;letは実際のところ、ラムダ抽象へ置換可能ので、最低限の機能を持ったLisp実装する上では、 態々実装する必要はない。しかし、letを先に実装しておくと、後のラムダ抽象の実装が楽になる。&lt;/p&gt;&lt;h1 id=&quot;ラムダ抽象と関数適用の追加実装&quot;&gt;ラムダ抽象と関数適用の追加実装&lt;/h1&gt;&lt;p&gt;ラムダ抽象&lt;a href='#fn-1' id='fnref1'&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;は大体、以下のような式。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;lambda &amp;#40;x&amp;#41; ...&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このラムダ抽象の実装は、eval関数に、ラムダ抽象が与えられた場合にクロージャを返す処理を追加し、 関数適用にクロージャが関数として与えられた場合の処理を追加する。&lt;/p&gt;&lt;h1 id=&quot;ひとまずゴール&amp;#95;-&amp;#95;足りない機能はラムダ計算で補う&quot;&gt;ひとまずゴール - 足りない機能はラムダ計算で補う&lt;/h1&gt;&lt;p&gt;ここまでくれば、ひとまず、プログラミング言語としては完成。&lt;/p&gt;&lt;p&gt;ループはYコンビネータによる再帰で実現させる。&lt;/p&gt;&lt;p&gt;ラムダ抽象(と関数適用)を実装したことで、Yコンビネータによる再帰が可能になる。 YコンビネータとはSchemeで書くと以下のような式。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;lambda &amp;#40;f&amp;#41; &amp;#40;&amp;#40;lambda &amp;#40;p&amp;#41; &amp;#40;f &amp;#40;lambda &amp;#40;a&amp;#41; &amp;#40;&amp;#40;p p&amp;#41; a&amp;#41;&amp;#41;&amp;#41;&amp;#41; &amp;#40;lambda &amp;#40;p&amp;#41; &amp;#40;f &amp;#40;lambda &amp;#40;a&amp;#41; &amp;#40;&amp;#40;p p&amp;#41; a&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このコンビネータに対して、例えば、以下の再帰的な関数fibを(引数として)与える。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;lambda &amp;#40;fib&amp;#41; &amp;#40;lambda &amp;#40;n&amp;#41; &amp;#40;if &amp;#40;= n 0&amp;#41; 0 &amp;#40;if &amp;#40;= n 1&amp;#41; 1 &amp;#40;+ &amp;#40;fib &amp;#40;- n 1&amp;#41;&amp;#41; &amp;#40;fib &amp;#40;- n 2&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;すると、以下の式のクロージャが生成される。この時のクロージャが持つ環境の変数fibには自分自身の以下の式が束縛されている。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;lambda &amp;#40;n&amp;#41; &amp;#40;if &amp;#40;= n 0&amp;#41; 0 &amp;#40;if &amp;#40;= n 1&amp;#41; 1 &amp;#40;+ &amp;#40;fib &amp;#40;- n 1&amp;#41;&amp;#41; &amp;#40;fib &amp;#40;- n 2&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このクロージャfibに&lt;code&gt;&amp;#40;fib 10&amp;#41;&lt;/code&gt;などの関数適用を行うことで再帰呼出しが実現する。&lt;/p&gt;&lt;p&gt;また、データ構造も実装してないように思えるかも知れないが、これまたラムダ計算でcons/car/cdrを表現する手法がある。 したがって、ラムダ抽象を実装した時点で、すでにリスト構造の実装も終わっていた。&lt;/p&gt;&lt;p&gt;というわけで、最低限の機能を持ったプログラミング言語が実装できたと結論付ける。&lt;/p&gt;&lt;h1 id=&quot;その他のtodo&quot;&gt;その他のTODO&lt;/h1&gt;&lt;p&gt;以上から、プログラミング言語を実装したも同然だが、当然、言語としては物足りない。&lt;/p&gt;&lt;p&gt;基本的には処理系の実装をサボった分だけ、作った言語(処理系)でプログラムを書くのが大変になる。 例えば、再帰呼出しを書くたびにYコンビネータを使うという辛みが残ってしまう。&lt;/p&gt;&lt;p&gt;というわけで、以下のようなTODOが残ることとなる。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;部分適用&lt;/li&gt;&lt;li&gt;letrecでプリミティブな再帰を実装&lt;/li&gt;&lt;li&gt;グローバル環境に変数を束縛&lt;/li&gt;&lt;li&gt;その他、文字列の実装、組み込みデータ型の実装など (あとは自由に拡張してくだけ)&lt;/li&gt;&lt;li&gt;コンパイラの実装など... etc&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;まあこの辺は、のんびり実装すればいいと思うが。&lt;/h2&gt;&lt;h2&gt;&lt;/h2&gt;脚注&lt;ol class='footnotes'&gt;&lt;li id='fn-1'&gt;別名、ラムダ式とか無名関数と言ったりするが、ラムダ式という言い方は、後述するラムダ計算のラムダ式と紛らわしい。したがって、ラムダ抽象と書いておくこととする。&lt;a href='#fnref1'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<pubDate>
Sat, 26 Aug 2017 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
https://yuwki0131.github.io/posts-output/2017-08-11-scala-type-mismatch-option/
</guid>
<link>
https://yuwki0131.github.io/posts-output/2017-08-11-scala-type-mismatch-option/
</link>
<title>
Scalaで、再代入時にOptionを使おうとしたらtype-mismatch
</title>
<description>
&lt;p&gt;Scalaに入門して少し経ちましたが、コードを書いていると早速、型推論でのエラーが発生して少し悩みました。 Option型で再代入可能な変数(varで宣言した変数)に再代入しようとした箇所に、エラーが発生。&lt;/p&gt;&lt;p&gt;ざっくりと書くと、以下のような感じでエラーが発生しました。。。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;scala&amp;gt; var x = None
var x = None
x: None.type = None

scala&amp;gt; x = Some&amp;#40;10&amp;#41;
x = Some&amp;#40;10&amp;#41;
&amp;lt;console&amp;gt;:8: error: type mismatch;
 found   : Some&amp;#91;Int&amp;#93;
 required: None.type
       x = Some&amp;#40;10&amp;#41;
               &amp;#94;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;実際のコードは上記と異なり、replで実行したコードではなく、 メソッド内でvarの変数を定義し、そこに再代入を行う以下のような処理ですが、意味的には上記と同じような状況です。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;var x = None

// 様々な処理

x = Some&amp;#40;10&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先に変数xにNoneを代入しておいて、あとから、Some(〜)を再代入しようとした処理を書くという流れです。&lt;/p&gt;&lt;p&gt;Noneを初期値として入れておいた変数xに後からSome(〜)を代入する処理を書こうとすれば、当然、コンパイラの側でOption型を 推論してくれるものと思っていたのですが、甘かった。&lt;/p&gt;&lt;p&gt;replだとなんとなく分かりますが、初期値を代入した時点では、var xの型はNone.typeとなってしまい、Option型ではありません。 問題は、コンパイラが後から変数xはNone.typeではなく、Option[Int]型であるといった推論をしてくれないことにあります。&lt;/p&gt;&lt;p&gt;先にNoneを代入した後に、Someを代入する場合は、変数がOption型であることを先に明示しておく必要があります。 型注釈を以下のようにつけると、変数がOption型であることを認識して、Option型の再代入が可能になります。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;scala&amp;gt; var x = None:Option&amp;#91;Int&amp;#93;
var x = None:Option&amp;#91;Int&amp;#93;
x: Option&amp;#91;Int&amp;#93; = None

scala&amp;gt; x = Some&amp;#40;10&amp;#41;
x = Some&amp;#40;10&amp;#41;
x: Option&amp;#91;Int&amp;#93; = Some&amp;#40;10&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;そもそもなんでこんな言語仕様なのか、なぜ、このような挙動をするのか、詳しく調べた訳ではないですが、 以下にそれらしい内容が載っていました。&lt;/p&gt;&lt;p&gt;&lt;a href='https://togetter.com/li/219702'&gt;Scalaの型推論について - Togetterまとめ&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Scalaの型推論では、基本的に前方から順に型推論し、後方で想定外の型であると型エラーが発生する仕組みになっている。&lt;/li&gt;&lt;li&gt;強力な型推論を行った場合、型エラーが分かりづらくなるため、上記のような弱い推論方法を採用しているのかも知れない。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;とのこと。&lt;/p&gt;&lt;p&gt;時代的にみてもScalaは、SystemFが登場した後に設計された(2001年ごろ〜)言語で、 すでにHaskellやOCamlなど強力な型推論システムを持つ実用的な言語が既に登場しています。 にも関わらず、このような設計にっているのは、型エラーの複雑さ(わかりづらさ)を回避したい狙いがあった、ということのようです。&lt;/p&gt;&lt;p&gt;前方から型推論していくと考えると、型エラーの分かりづらさはかなり軽減されそうです。 上記のエラーは、その辺りのトレードオフを考えてた上での、型エラーとという事のなのでしょう。&lt;/p&gt;
</description>
<pubDate>
Fri, 11 Aug 2017 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
https://yuwki0131.github.io/posts-output/2017-08-05-rename-title/
</guid>
<link>
https://yuwki0131.github.io/posts-output/2017-08-05-rename-title/
</link>
<title>
ブログのタイトル変えました
</title>
<description>
&lt;p&gt;ブログのタイトル(yuwki0132-blog)が酷いので、パウル・クレーの絵画「何で走っているのだろう」からタイトルを拝借しました。&lt;/p&gt;
</description>
<pubDate>
Sat, 05 Aug 2017 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
https://yuwki0131.github.io/posts-output/2017-08-03-haskell-points/
</guid>
<link>
https://yuwki0131.github.io/posts-output/2017-08-03-haskell-points/
</link>
<title>
Haskellの躓きポイントまとめのまとめ
</title>
<description>
&lt;p&gt;Haskellの躓きポイント。上が、Tatsuki氏によるもの。下が、るじゃ氏によるもの。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href='http://qiita.com/Tatsuki-I/items/01d7f4ce9c0a2fff94a2'&gt;Haskellで躓いた(躓いてる)ポイントまとめ #Haskell - Qiita&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href='http://lugendre.hatenablog.com/entry/2017/08/02/200542'&gt;Haskellでつまずいた所まとめ - 中級プログラマを目指す&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;躓きポイントがわかると、勉強対象が明確になって良いですね。&lt;/p&gt;&lt;p&gt;※ちなみにこの投稿は、Cryogen向けのEmacsの設定のテストを兼ねています。&lt;/p&gt;
</description>
<pubDate>
Thu, 03 Aug 2017 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
https://yuwki0131.github.io/posts-output/2017-08-02-cryogen-workflow/
</guid>
<link>
https://yuwki0131.github.io/posts-output/2017-08-02-cryogen-workflow/
</link>
<title>
Cryogen/Github-Pagesでブログを書く
</title>
<description>
&lt;p&gt;とりあえず、一通り、Cryogen/Github-Pagesで静的なWebページの公開までたどり着いたので、その紹介などをざっくりと書きます。&lt;/p&gt;&lt;h3 id=&quot;cryogenでブログ作成〜github-pagesで公開まで&quot;&gt;Cryogenでブログ作成〜Github-Pagesで公開まで&lt;/h3&gt;&lt;p&gt;主にやったこととしては、&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Cryogenのプロジェクトをリモートリポジトリ(BitBucket&lt;a href='#fn-1' id='fnref1'&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;)にまるごと登録&lt;/li&gt;&lt;li&gt;諸々の設定ファイルを修正&lt;/li&gt;&lt;li&gt;とりあえず、最初の記事を書く&lt;/li&gt;&lt;li&gt;ローカル環境で表示確認のテスト&lt;/li&gt;&lt;li&gt;username.github.ioのリポジトリを作成&lt;/li&gt;&lt;li&gt;Cryogenで作成生成されたpublicファイルをgithub.ioのリポジトリに登録&lt;ul&gt;&lt;li&gt;とりあえず静的Webサイト(ブログ一式)が公開される&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ビーコン設置&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;といった流れで作成しました。&lt;/p&gt;&lt;p&gt;Cryogenでのブログ作成については、公式の&lt;a href='https://github.com/cryogen-project/cryogen/blob/master/README.md'&gt;README.md&lt;/a&gt; を見ながら作ったという感じです。&lt;/p&gt;&lt;p&gt;ドキュメント(&lt;a href='http://cryogenweb.org'&gt;cryogenweb.org&lt;/a&gt;)も整備されていたりします。&lt;/p&gt;&lt;p&gt;設定ファイルですが、主に以下のファイルに必要な情報を書き込んでいきます。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;プロジェクトルート/resources/templates/config.edn
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;テーマは、今後変更する予定ですが、とりあえずデフォルトのテーマを使うことにしてます。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;プロジェクトルート/resources/templates/themes/blue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;デフォルトのテーマは上記にあるので、その辺りを自分好みに修正しました。 今後は、もっと修正をかけまくる or 別テーマにする予定です。今のテーマ、 残念ながら私好みでないので。。。&lt;/p&gt;&lt;p&gt;ブログ記事の生成は通常のleiningenを走らせるのと同様、&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein run
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;で生成できます。ローカルで生成結果を確認したい場合は、&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein ring server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;などとするとページが表示され確認可能です。&lt;/p&gt;&lt;p&gt;この時、サーバを立ち上げっぱなしにしておくと、記事を修正とブラウザの更新を繰り返すことで 記事を書きながらその内容を即座に確認するといったことが可能になります。&lt;/p&gt;&lt;p&gt;記事は日付とタイトルを付けて以下に格納します。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;プロジェクトルート/resources/templates/md/posts/YYYY-MM-dd-post-title.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cryogenでは、resource/template配下のファイルを読み取り、resource/public配下に公開可能な静的Webコンテンツ一式を出力します。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;プロジェクトルート/resources/templates
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;プロジェクトルート/resources/public
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Github PagesのリポジトリにCryogenで生成したpublic下ファイルを登録することで、ブログとして公開できます。&lt;/p&gt;&lt;p&gt;後は、アクセス情報なんかも欲しいので、以下の記事を見ながら、ga-beaconを使って見ました。&lt;/p&gt;&lt;p&gt;&lt;a href='http://qiita.com/kabayan55/items/f15c822939b2ab7dba35'&gt;GitHub Pagesでga-beaconを使ってリアルタイムアクセス解析 - Quiita&lt;/a&gt;&lt;/p&gt;&lt;p&gt;以下の記事を見た感じだと、Cryogenでページ生成した場合、Google Analiticsを使う場合は、 やっぱり、base.html&lt;a href='#fn-2' id='fnref2'&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;下にタグを埋め込む(人が多い)のかなぁ、といった感じです。&lt;/p&gt;&lt;p&gt;&lt;a href='https://github.com/cryogen-project/cryogen/issues/88'&gt;feature request - google analytics support (solved if i add docs :-)) #88&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;プロジェクトルート/resources/templates/themes/blue/html/base.html
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;今後の記事を書く流れ&quot;&gt;今後の記事を書く流れ&lt;/h3&gt;&lt;p&gt;今後の記事公開までの主な流れとしては、&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ローカルでブログ記事を書く&lt;/li&gt;&lt;li&gt;ページ生成とローカルで記事の表示テスト&lt;/li&gt;&lt;li&gt;リモートリポジトリにまるごと差分をコミット&lt;/li&gt;&lt;li&gt;生成されたページをGithub-Pagesにコミット/プッシュで、公開&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;かな、と思ってます。&lt;/p&gt;&lt;p&gt;あとは、ブログのデザインについても適宜修正していく予定です。 特に最近は、&lt;a href='https://www.flaticon.com/'&gt;flaticon.com&lt;/a&gt; がお気に入りなので、 ぜひ使わせていただければと考えています。&lt;/p&gt;&lt;h3 id=&quot;感想など&quot;&gt;感想など&lt;/h3&gt;&lt;p&gt;色々、設定は面倒ですが、Emacsで記事が書けるようになった点が幸せですね。 また、手元でファイル管理できるという点も既存のブログサイトの利用より、メリットがあるのではと思っています。 versionコントロールもしやすいので。 &lt;ol class='footnotes'&gt;&lt;li id='fn-1'&gt;別にGithubに登録してもよかったのですが、無駄にリポジトリは公開したくない主義なので。。。&lt;a href='#fnref1'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;li id='fn-2'&gt;base.htmlは、テーマ直下にあるテンプレートのベースとなるhtmlです。&lt;a href='#fnref2'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;
</description>
<pubDate>
Wed, 02 Aug 2017 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
https://yuwki0131.github.io/posts-output/2017-08-01-quickstart/
</guid>
<link>
https://yuwki0131.github.io/posts-output/2017-08-01-quickstart/
</link>
<title>
CryogenでブログのQuick Startをしてみた
</title>
<description>
&lt;h3 id=&quot;ブログを書く時の物理的/心理的ハードル&quot;&gt;ブログを書く時の物理的/心理的ハードル&lt;/h3&gt;&lt;p&gt;長らくGoogle Bloggerを使ってプログラミング関連をネタとしたブログを書いてきました。&lt;/p&gt;&lt;p&gt;Google Bloggerも良かったのですが、自前のサーバーでもブログ書きたいなとか、記事がmarkdownで書けないとか、 そもそもEmacsで書けないとか不満が色々出てきました。&lt;/p&gt;&lt;p&gt;そして何より、気づいたら、ブログを書くハードルが高くなってました。&lt;/p&gt;&lt;p&gt;色々思う所があり、1記事書くのにかかるコスト感が半端ない感じで上がりました。&lt;/p&gt;&lt;p&gt;以下、色々思う所です。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;HelloWorld的な基礎的な内容や簡単な備忘録程度ならわざわざブログに書く必要性が感じられない。&lt;/li&gt;&lt;li&gt;日本語で他の記事を参照すれば分かるような内容は書きたくない(書く意味がない)。&lt;/li&gt;&lt;li&gt;リファレンスは? エビデンスは?&lt;/li&gt;&lt;li&gt;(他人がどう思うかはとりあえず置いとくとして、そもそも)自分が面白いと思える内容なのか?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;しかし以上の思い込みは、アウトプットする行為と比較すると非常に下らない考えです。&lt;/p&gt;&lt;p&gt;この心理的ハードルをEmacsとMarkdwonとClojureの力で下げたい!&lt;/p&gt;&lt;h3 id=&quot;cryogenでマイクロ技術ブログ的な何かを行う試み。&quot;&gt;Cryogenでマイクロ技術ブログ的な何かを行う試み。&lt;/h3&gt;&lt;p&gt;というわけで、Google Bloggerより手軽に記事を書ける環境を探していた所、 Cryogen使えばいいじゃんという結論に落ち着きました。。。&lt;/p&gt;&lt;p&gt;Cryogenは、Clojureで作られた静的サイトジェネレータです。ClojureのWebサーバringと一緒に使うことで、ブログサイトを簡単に構築できます。 以下の公式ページを見た方が早いですが、非常に簡単にblogが立ち上がります。&lt;/p&gt;&lt;p&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;a href='https://github.com/cryogen-project/cryogen'&gt;Cryogen&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;&lt;p&gt;基本的にサーバでCryogenのプロジェクトを走らせといて、適当なディレクトリ (プロジェクト・ルート/resources/templates/md/posts/配下)に Markdown(or AsciiDocも使えます)を突っ込んどけば、サーバ側でいい感じに静的なブログを作ってくれるという仕組みです。 RSSフィードなども自動生成してくれるようで有りがたいです。&lt;/p&gt;&lt;p&gt;また、金銭的な都合で、Github Pagesを使うことにしました。&lt;/p&gt;
</description>
<pubDate>
Tue, 01 Aug 2017 00:00:00 +0900
</pubDate>
</item>
</channel>
</rss>
